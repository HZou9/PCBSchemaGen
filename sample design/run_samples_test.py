import os
import sys
import subprocess
import py_compile
import logging
import shutil
import glob
import re
import time

# ==========================================
# Configuration & Setup Section (Injectable)
# ==========================================

def setup_library_paths():
    """Configures SKiDL library paths and Environment Variables."""
    try:
        from skidl import lib_search_paths, footprint_search_paths, KICAD

        kicad_sym_dir = "/usr/share/kicad/symbols"
        if os.path.exists(kicad_sym_dir):
            os.environ["KICAD_SYMBOL_DIR"] = kicad_sym_dir
            # Set for all versions to suppress warnings
            os.environ["KICAD9_SYMBOL_DIR"] = kicad_sym_dir
            os.environ["KICAD8_SYMBOL_DIR"] = kicad_sym_dir
            os.environ["KICAD7_SYMBOL_DIR"] = kicad_sym_dir
            os.environ["KICAD6_SYMBOL_DIR"] = kicad_sym_dir
        
        if '__file__' in globals():
            current_dir = os.path.dirname(os.path.abspath(__file__))
        else:
            current_dir = os.getcwd()
            
        if 'sample design' in current_dir:
            project_root = os.path.dirname(current_dir)
        else:
            project_root = os.path.dirname(current_dir)

        libs_dir = os.path.join(project_root, 'library')
        
        if os.path.exists(libs_dir):
            if libs_dir not in lib_search_paths[KICAD]:
                lib_search_paths[KICAD].append(libs_dir)
            
            fp_paths = footprint_search_paths[KICAD]
            if isinstance(fp_paths, list):
                if libs_dir not in fp_paths:
                    fp_paths.append(libs_dir)
    except Exception as e:
        print(f"[Config] CRITICAL ERROR: Error setting up paths: {e}")

def setup_logging():
    """Configures logging filters."""
    class ERCTagFilter(logging.Filter):
        def filter(self, record):
            msg = record.getMessage()
            if "Tag" in msg or "tag" in msg:
                return False
            return True

    skidl_logger = logging.getLogger('skidl')
    skidl_logger.addFilter(ERCTagFilter())

def setup():
    setup_library_paths()
    setup_logging()

# ==========================================
# Test Runner Section
# ==========================================

def check_syntax(py_file: str) -> bool:
    try:
        py_compile.compile(py_file, doraise=True)
        return True
    except py_compile.PyCompileError as e:
        print(f'[SYNTAX FAIL] {py_file}: {e.msg}')
        return False

def force_delete(path):
    """Aggressively tries to delete a file, waiting if necessary."""
    retries = 3
    while retries > 0:
        if os.path.exists(path) and os.path.isfile(path):
            try:
                os.remove(path)
                return
            except OSError as e:
                time.sleep(0.2)
                retries -= 1
        else:
            return

def nuke_junk_files():
    """
    Nuclear cleanup of any file starting with skidl_repl or temp_p in the current dir.
    """
    for f in glob.glob("skidl_repl*"):
         force_delete(f)
    for f in glob.glob("temp_p*"):
         force_delete(f)
    for f in glob.glob("*.log"): # Be careful not to delete execution.log inside folders
         if os.path.dirname(f) == "": # only in root
            force_delete(f)

def move_artifacts_to_results(temp_base_name, real_task_id):
    real_base = f"p{real_task_id}"
    results_dir = f"{real_base}_results"
    
    if not os.path.exists(results_dir):
        os.makedirs(results_dir)
        
    # Pattern 1: TEMP files (temp_p1.net) -> Rename to p1.net
    match_pattern = f"{temp_base_name}.*"
    for src_path in glob.glob(match_pattern):
        if src_path.endswith(".py"): continue
        if "sklib" in src_path: 
            force_delete(src_path)
            continue
            
        ext = os.path.splitext(src_path)[1]
        dest_name = f"{real_base}{ext}"
        dest_path = os.path.join(results_dir, dest_name)
        
        force_delete(dest_path) # clear old result
        shutil.move(src_path, dest_path)

    # Pattern 1b: Preserve .dot files (Graphviz) generated by generate_graph()
    # These often usually just appear as "schematic.dot" or similar in current dir
    for f in glob.glob("*.dot"):
        dest_name = f"{real_base}.dot"
        dest_path = os.path.join(results_dir, dest_name)
        force_delete(dest_path)
        shutil.move(f, dest_path)

    # Pattern 1c: Preserve .sch files (Legacy Schematic) generated by generate_schematic()
    for f in glob.glob("*.sch"):
        dest_name = f"{real_base}.sch"
        dest_path = os.path.join(results_dir, dest_name)
        force_delete(dest_path)
        shutil.move(f, dest_path)
        
    # Pattern 2: skidl_repl JUNK -> Rename to p1.net if duplication, else just save
    # SKiDL sometimes defaults to skidl_repl even if we name the script
    for f in glob.glob("skidl_repl*"):
        if os.path.isfile(f):
            ext = os.path.splitext(f)[1]
            dest_name = f"{real_base}{ext}" 
            dest_path = os.path.join(results_dir, dest_name)
            
            force_delete(dest_path)
            shutil.move(f, dest_path)

    # Pattern 3: skidl.log
    if os.path.exists("skidl.log"):
        shutil.move("skidl.log", os.path.join(results_dir, "skidl.log"))

    # Pattern 4: .kicad_pcb files
    # The injected generate_pcb() without filename might generate 'temp_pX.kicad_pcb' or 'skidl.kicad_pcb'?
    # It usually defaults to the name of the script.
    # We will look for *.kicad_pcb
    for f in glob.glob("*.kicad_pcb"):
        dest_name = f"{real_base}.kicad_pcb"
        dest_path = os.path.join(results_dir, dest_name)
        force_delete(dest_path)
        shutil.move(f, dest_path)

def run_task_isolated(py_file, task_id):
    module_name = os.path.splitext(py_file)[0]
    temp_script_name = f"temp_{module_name}.py"
    
    # 1. Pre-Run Cleanup
    nuke_junk_files()

    with open(py_file, 'r') as f:
        original_code = f.read()
        
    # Inject logic (Header)
    injection_header = f"""
import sys
import os
kicad_sym_dir = "/usr/share/kicad/symbols"
if os.path.exists(kicad_sym_dir):
    os.environ["KICAD_SYMBOL_DIR"] = kicad_sym_dir
    os.environ["KICAD9_SYMBOL_DIR"] = kicad_sym_dir
    os.environ["KICAD8_SYMBOL_DIR"] = kicad_sym_dir
    os.environ["KICAD7_SYMBOL_DIR"] = kicad_sym_dir
    os.environ["KICAD6_SYMBOL_DIR"] = kicad_sym_dir

sys.path.append(os.getcwd()) 
import run_samples_test
run_samples_test.setup()
"""

    # Inject logic (Footer - Artifact Generation)
    # Allows pX.py to just define circuit and call ERC()
    injection_footer = f"""
# --- Injected Generation Logic ---
import os
generation_failed = False
try:
    # Ensure KICAD9 tool usage for netlist
    generate_netlist(tool=KICAD9)
except Exception as e:
    generation_failed = True
    print(f"ERC INFO: Error generating netlist: {{e}}")

try:
    generate_svg()
except Exception as e:
    generation_failed = True
    print(f"ERC INFO: Error generating SVG: {{e}}")

try:
    # Configure Footprint Libraries
    # We add the local '../library' and '../library/datasheets' (if applicable) 
    # strictly pointing to the 'library' folder where .pretty folders usually reside or .kicad_mod files?
    # Actually, SKiDL usually looks for .pretty folders for footprints.
    # Our 'library' folder contains .kicad_sym and .pretty folders? 
    # Let's point to the project root 'library' directory.
    
    lib_path = os.path.abspath(os.path.join(os.getcwd(), "../library"))
    test_lib = os.path.join(lib_path, "test.pretty")
    # Adding both parent and specific lib path to cover all bases
    generate_pcb(fp_libs=[lib_path, test_lib])
except Exception as e:
    # If generate_pcb fails (e.g. pcbnew not found), we catch it
    generation_failed = True
    print(f"ERC INFO: Error generating PCB: {{e}}")

if generation_failed:
    sys.exit(1)
"""
    
    with open(temp_script_name, 'w') as f:
        f.write(injection_header + original_code + injection_footer)
        
    cmd = [sys.executable, temp_script_name]
    env = os.environ.copy()
    kicad_sym_dir = "/usr/share/kicad/symbols"
    env["KICAD_SYMBOL_DIR"] = kicad_sym_dir
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            text=True,
            env=env
        )
        
        # Give OS filesystem a moment to sync file handles
        time.sleep(0.5)
        
        # 2. Harvest Artifacts
        move_artifacts_to_results(os.path.splitext(temp_script_name)[0], task_id)
        
        # 3. Save Logs (Splitting Logic)
        results_dir = f"p{task_id}_results"
        if not os.path.exists(results_dir): os.makedirs(results_dir)
        
        # Combine stdout and stderr for parsing
        full_output = result.stdout + "\n" + result.stderr
        
        erc_lines = []
        other_lines = []
        
        # Regex to capture ERC block
        # Usually starts with "ERC ..." and ends with "ERC INFO: ... errors found"
        # Since SKiDL dumps it in stream, we'll grep for lines starting with "ERC "
        
        for line in full_output.splitlines():
            if line.strip().startswith("ERC "):
                erc_lines.append(line)
            else:
                other_lines.append(line)
                
        # Write .erc (Strictly ERC output as requested)
        with open(os.path.join(results_dir, f"p{task_id}.erc"), "w") as f:
            f.write("\n".join(erc_lines) + "\n")
            
        # Write .log (Everything else, including "INFO: x warnings..." summaries)
        with open(os.path.join(results_dir, f"p{task_id}.log"), "w") as f:
            f.write("\n".join(other_lines) + "\n")

        return result.returncode == 0
        
    finally:
        # 4. Post-Run NUCLEAR CLEANUP
        nuke_junk_files()

def patch_library():
    """
    Patches the KiCad Symbol Library to avoid SKiDL SVG generation bugs.
    The bug is caused by multi-value justification like '(justify left top)' which SKiDL parses as a list.
    We replace all justifications with '(justify center)' as per user request to avoid any list attributes.
    """
    lib_path = "../library/test.kicad_sym"
    if not os.path.exists(lib_path):
        print(f"WARNING: Library not found at {lib_path}")
        return

    print(f"Patching library {lib_path} for SVG compatibility...")
    with open(lib_path, 'r') as f:
        content = f.read()
    
    # Replace (justify value value) or (justify value) with (justify center)
    # Using regex to be safe and cover all variations including left/right/top/bottom
    import re
    # Pattern looks for (justify ...) and replaces entire parenthesized group
    # Be careful not to match too much. Justify usually is (justify align) or (justify align align)
    # We'll use a simple regex for the specific problem inputs found
    
    # Option 1: Simple replace of known problem patterns
    # Restore valid left/right justification. SKiDL SVG crashes on 'center'.
    
    # 1. Rescue from previous bad patch (justify center) -> (justify left)
    new_content = re.sub(r'\(justify center\)', '(justify left)', content)
    
    # 2. Fix double justification (justify left top) -> (justify left)
    new_content = re.sub(r'\(justify left [a-z]+\)', '(justify left)', new_content)
    
    # 3. Fix double justification (justify right top) -> (justify right)
    new_content = re.sub(r'\(justify right [a-z]+\)', '(justify right)', new_content)

    with open(lib_path, 'w') as f:
        f.write(new_content)

def clean_all_results():
    """Aggressively remove all p*_results directories."""
    print("Nuking all old results directories...")
    for d in glob.glob("*_results"):
        shutil.rmtree(d)

def main():
    # Setup
    patch_library()
    clean_all_results()
    nuke_junk_files() # Clean BEFORE starting any loop

    failed = []
    # task_ids = [1, 2, 3, 4, 5, 6, 7, 13, 14, 15, 16] # Existing samples
    # We will detect all pX.py files
    
    all_files = glob.glob("p*.py")
    task_ids = []
    for f in all_files:
        # extract number
        try:
            num = int(re.findall(r'\d+', f)[0])
            task_ids.append(num)
        except:
            pass
    task_ids = sorted(list(set(task_ids)))

    print(f"Running tasks: {task_ids}")
    
    for t_id in task_ids:
        py_file = f"p{t_id}.py"

        if not os.path.exists(py_file): continue
            
        if not check_syntax(py_file):
            print(f"[SYNTAX FAIL] Task {t_id}")
            failed.append(t_id)
            continue
            
        success = run_task_isolated(py_file, t_id)
        if success:
            print(f"[PASS] Task {t_id}")
        else:
            print(f"[FAIL] Task {t_id}")
            failed.append(t_id)

    # One final check
    garbage = glob.glob("skidl_repl*") + glob.glob("temp_p*")
    if garbage:
        print("WARNING: Garbage files survived cleanup: ", garbage)
        for g in garbage: force_delete(g)

    if failed:
        sys.exit(1)
    else:
        sys.exit(0)

if __name__ == '__main__':
    if len(sys.argv) == 1:
        main()
